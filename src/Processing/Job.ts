import { InputStream, Listener } from "../IO/InputStream";
import { OutputStream } from "../IO/OutputStream";
import { FieldQualifier } from "../Parser/FieldQualifer";
import { FilterClauseAstNode } from "../Parser/FilterClauseAstNode";
import { FilterField } from "../Parser/FilterField";
import { SourceClauseAstNode } from "../Parser/SourceClauseAst";
import { OutputClauseAstNode } from "../Parser/OutputClauseAst";
import { QueryAst } from "../Parser/QueryAst";
import { SelectionClauseAstNode } from "../Parser/SelectionClauseAstNode";

type Dictionary<T> = { [key: string]: T }
/**
 * An event composed of events from several sources, using the source name
 * as a key.
 */
type ComplexEvent = Dictionary<any>
type Projector = (complexEvent: ComplexEvent) => any
type Filter = (complexEvent: ComplexEvent) => boolean
type Output = (evt: any) => void

/**
 * Get field from an event composed from events from several inputs, using a field qualifier
 * @param complexEvent 
 * @param field 
 * @returns 
 */
function getField(complexEvent: ComplexEvent, field: FieldQualifier): any {
  let res = complexEvent[field.input]
  for (let qualifier of field.qualifiers) {
    console.log(qualifier)
    if (res === undefined) {
      return undefined
    }
    res = res[qualifier]
  }
  return res;
}

/**
 * Copy all properties of object into target
 * @param from 
 * @param to 
 */
function copyObject(from: any, to: any): any {
  Object.keys(from).forEach(key => to[key] = from[key])
}

/**
 * Copy all properties in events constituting a complex event
 * into target
 * @param complexEvent 
 * @param target 
 */
function copyFromComplexEvent(complexEvent: ComplexEvent, target: any): any {
  Object.values(complexEvent).forEach(obj => copyObject(obj, target))
}

/**
 * Creates a job from a fully parsed query.
 */
export class Job {
  /**
   * Compiles the query, create a job from it. Registers all listeners.
   * 
   * Execution plan =
   * 1. JOIN
   * 2. GROUP BY (NOT SUPPORTED YET)
   * 3. FILTER
   * 4. PROJECT
   * 5. OUTPUT
   * 
   * @param query 
   * @param availableInputs 
   * @param outputs 
   */
  constructor(query: QueryAst, private availableInputs: InputStream[], private outputs: OutputStream[]) {
    const filter = this.generateFilter(query.filterClause)
    const projector = this.generateProjector(query.selectionClause)
    const output = this.generateOutput(query.outputClause)
    // Add an event listener for all sources in the query
    const inputs = this.getInputs(query.fromClause)
    inputs.forEach(input => {
      input.addListener(this.createEventListener(input, filter, output, projector))
    })
  }

  /**
   * Compiled event listener to run everytime we run a new event.
   * @param input Input to which to attach
   * @param filter 
   * @param output 
   * @param projector 
   * @returns 
   */
  private createEventListener(input: InputStream, filter: Filter, output: Output, projector: Projector): Listener {
    return (evt) => {
      const sources: Dictionary<any> = {}
      sources[input.params.name] = evt.body;
      if (filter(sources)) {
        output(projector(sources))
      }
    }
  }

  /**
   * Generate an output function where to push events generated by the query
   * @param outputClause 
   * @returns 
   */
  private generateOutput(outputClause: OutputClauseAstNode) {
    const output = this.outputs.find(output => outputClause.output === output.name)
    if (!output) {
      throw Error(`Output not found: "${outputClause.output}"`)
    }
    return (evt: any) => output.pushEvent(evt)
  }

  /**
   * Retrieve all inputs matching the from clause, and registering to all of them
   * @param fromClause 
   * @returns 
   */
  private getInputs(fromClause: SourceClauseAstNode): InputStream[] {
    const inputsInQuery = [fromClause.mainInput].concat(fromClause.joins.map(join => join.input))
    return inputsInQuery.map(inputInQuery => {
      const input = this.availableInputs.find(input => input.params.name === inputInQuery);
      if (!input) {
        throw Error(`Input not found: "${inputInQuery}"`)
      }
      return input;
    });
  }

  /**
   * Generate a filter function from the FILTER clause
   * @param filterClause 
   * @returns 
   */
  private generateFilter(filterClause: FilterClauseAstNode | null): Filter {
    if (!filterClause) {
      return () => true
    }
    const valueA = this.generateValueSelector(filterClause.partA)
    const valueB = this.generateValueSelector(filterClause.partB)
    const operators = {
      ">": (a: any, b: any) => a > b,
      ">=": (a: any, b: any) => a >= b,
      "<": (a: any, b: any) => a < b,
      "<=": (a: any, b: any) => a <= b,
      "==": (a: any, b: any) => a == b,
      "!=": (a: any, b: any) => a != b,
    }
    const operator = operators[filterClause.comparator]
    return (sources: ComplexEvent) => {
      const a = valueA(sources);
      const b = valueB(sources);
      return operator(a, b)
    }
  }

  /**
   * Generate a function that will select the value to be used in the filter.
   * @param field 
   * @returns 
   */
  private generateValueSelector(field: FilterField) {
    if (field.type === "numericValue") {
      return () => field.value as number
    } else if (field.type === "stringValue") {
      return () => field.value as string
    } else {
      const fieldQualifier = field.value as FieldQualifier
      return (complexEvent: ComplexEvent) => getField(complexEvent, fieldQualifier)
    }
  }

  /**
   * Generates a function to be used to map event to the output.
   * @param selectionClause 
   * @returns 
   */
  private generateProjector(selectionClause: SelectionClauseAstNode): Projector {
    let projectors: ((complexEvent: ComplexEvent, res: any) => void)[] = [];

    for (let field of selectionClause.fields) {
      const input = field.fieldQualifier?.input
      const fieldName = field.fieldQualifier?.qualifiers[0]
      if (input && !this.availableInputs.find(input => input.params.name === field.fieldQualifier?.input)) {
        throw Error(`Input stream not found: ${field.fieldQualifier?.input}`)
      }
      if (field.fieldType === "*") {
        projectors.push((sources: ComplexEvent, res: any) => copyFromComplexEvent(sources, res))
      } else if (field.fieldQualifier?.qualifiers[0] === "*") {
        projectors.push((sources: ComplexEvent, res: any) => copyObject(sources[input as string], res))
      } else {
        projectors.push((sources: ComplexEvent, res: any) => {
          res[fieldName as string] = getField(sources, field.fieldQualifier as FieldQualifier)
        })
      }
    }
    return (sources: ComplexEvent) => {
      const res = {}
      projectors.forEach(projector => projector(sources, res))
      return res;
    }
  }
}